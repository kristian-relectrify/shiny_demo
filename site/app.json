[{"name": "app.py", "content": "import pandas as pd\nimport plotly.graph_objects as go\nimport plotly.subplots as sp\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui, reactive\nfrom shinywidgets import output_widget, render_widget\nfrom shiny.types import FileInfo\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_file(\n                \"file1\", \"Choose CSV File\", accept=[\".csv\", \".log\"], multiple=False\n            ),\n            ui.input_select(\n                \"waveforms_to_plot\", \"Select waveforms to plot\", [], multiple=True\n            ),\n            ui.input_checkbox(\"normalize\", \"Normalize\", False),\n            ui.input_checkbox(\"hide_state\", \"Hide State\", False),\n            width=5,\n        ),\n        ui.panel_main(ui.output_ui(\"contents\"), output_widget(\"ac_debug\")),\n    ),\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    @reactive.Effect()\n    def _():\n        if input.file1() is not None:\n            f: list[FileInfo] = input.file1()\n            a, b = read_ac_logs(f[0][\"datapath\"])\n            ui.update_select(\n                \"waveforms_to_plot\",\n                label=\"Select waveforms to plot\",\n                choices=a.columns.to_list()[:-1],\n                selected=None,\n            )\n\n    @output\n    @render.ui\n    def contents():\n        if input.file1() is None:\n            return \"Please upload a csv file\"\n        f: list[FileInfo] = input.file1()\n        a, b = read_ac_logs(f[0][\"datapath\"])\n        df_agg = a.agg([\"max\", \"min\"]).T\n        return ui.HTML(df_agg.to_html(classes=\"table table-striped\"))\n\n    @output\n    @render_widget\n    def ac_debug():\n        if input.file1() is None:\n            return go.Figure()\n        f: list[FileInfo] = input.file1()\n        a, b = read_ac_logs(f[0][\"datapath\"])\n        return plot_ac_logs(\n            a,\n            b,\n            waveforms_to_plot=input.waveforms_to_plot(),\n            normalize=input.normalize(),\n            hide_state=input.hide_state(),\n        )\n\n    def read_ac_logs(f_data: str):\n        \"\"\"\n        Reads and process waveform and state data from logs\n        \"\"\"\n        d = pd.read_csv(\n            f_data,\n            sep=\",\",\n        )\n        d.columns = [c.strip() for c in d.columns]\n\n        # extract and process waveform data.\n        d_waveform = d.drop(\"block_state\", axis=1)\n        d_waveform[\"search_time\"] = d_waveform[\"search_time\"]\n        d_waveform[\"time\"] = list(range(d_waveform.shape[0]))\n\n        # extract and process block state data.\n        d_state = process_state_data(d[\"block_state\"])\n        d_state[\"state\"] = pd.Categorical(\n            d_state[\"state\"], categories=[\"A\", \"B\", \"C\"], ordered=True\n        )\n\n        return d_waveform, d_state\n\n    def process_state_data(d: pd.DataFrame, block_size: int = 8):\n        \"\"\"\n        Process ac stack beta log files.\n\n        \"\"\"\n\n        def get_state(x):\n            state_map = {\n                \"a\": 0,\n                \"b\": 1,\n                \"c\": 2,\n            }\n            blocks_state = x.strip()[1:].split(\"-\")\n\n            switch_state = [s[1:-1].strip().split(\"|\") for s in blocks_state]\n            switch_state_ = []\n            for i in range(len(switch_state)):\n                switch_state_.append(\n                    [int(state_map[s.lower()]) for s in switch_state[i]]\n                )\n\n            return switch_state\n\n        # reformats data to tidy data.\n        new_df = list()\n        for i, value in enumerate(d.apply(get_state)):\n            for r in range(len(value)):\n                for i_, c in enumerate(value[r]):\n                    new_df.append(\n                        {\n                            \"time\": i,\n                            \"block\": r,\n                            \"index\": -block_size * r + -1 * i_,\n                            \"state\": c,\n                        }\n                    )\n\n        return pd.DataFrame(new_df)\n\n    # Function to plot using Plotly\n    def plot_ac_logs(\n        d_waveform: pd.DataFrame,\n        d_state: pd.DataFrame,\n        waveforms_to_plot: list,\n        normalize: bool = False,\n        hide_state: bool = False,\n    ):\n        \"\"\"\n        Plots waveform and stat data as plotly interactive plots.\n        \"\"\"\n        n_blocks = d_state[\"block\"].nunique() if not hide_state else 0\n\n        fig = sp.make_subplots(\n            rows=1 + n_blocks,\n            cols=1,\n            row_heights=[2] + [1] * n_blocks,\n            shared_xaxes=True,\n        )\n\n        # Plot waveform\n        for wv in waveforms_to_plot:\n            fig.add_trace(\n                go.Scatter(\n                    x=d_waveform[\"time\"],\n                    y=d_waveform[wv]\n                    if not normalize\n                    else (\n                        (d_waveform[wv] - d_waveform[wv].min())\n                        / (d_waveform[wv].max() - d_waveform[wv].min())\n                    ),\n                    mode=\"lines\",\n                    name=wv,\n                )\n            )\n\n        fig.update_yaxes(gridcolor=\"rgba(0,0,0,0.2)\")\n\n        if not hide_state:\n            # Define a color scale for the legend\n            color_scale = {\"A\": \"red\", \"B\": \"green\", \"C\": \"blue\"}\n\n            # Plot node state\n            for k, block in enumerate(d_state[\"block\"].unique()):\n                state_data = d_state[d_state[\"block\"] == block]\n\n                for s_ in color_scale.keys():\n                    state_data_ = state_data[state_data[\"state\"] == s_]\n                    scatter = go.Scatter(\n                        x=state_data_[\"time\"],\n                        y=state_data_[\"index\"],\n                        legendgroup=s_,\n                        showlegend=k == 2,\n                        mode=\"markers\",\n                        marker=dict(\n                            size=6,\n                            color=color_scale[s_],\n                        ),\n                        name=s_,  # Unique legend name for each color/state\n                    )\n                    fig.add_trace(scatter, row=k + 2, col=1)\n                    fig.update_yaxes(gridcolor=\"rgba(0,0,0,0.2)\", row=k + 2, col=1)\n\n            fig.update_layout(height=300 + 150 * n_blocks, showlegend=True)\n            fig.update_xaxes(showticklabels=False)\n\n        return fig\n\n\napp = App(app_ui, server)\n", "type": "text"}]